# -*- coding: utf-8 -*-
"""SoftwareSolar.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mtplICZ8urZKb3_ThBR4-Ei1JYbXTL5u
"""

# ---------------------------------------------------------
# 3. UNIFICA√á√ÉO E FORMATA√á√ÉO VISUAL (TEXTO LIMPO)
# ---------------------------------------------------------
print("üé® Formatando textos para o Tooltip...")

# Juntar com a geometria das subesta√ß√µes
gdf_mapa = gdf_sub.merge(stats, left_on='COD_ID', right_index=True, how='left')

# Juntar com dados de Gera√ß√£o Distribu√≠da
gdf_mapa = gdf_mapa.merge(gd_sum, left_on='COD_ID', right_on='SUB', how='left')

# Preencher buracos com zero
gdf_mapa[['total_gd_kw', 'RE', 'CO', 'IN', 'pct_RE', 'pct_CO', 'pct_IN']] = \
    gdf_mapa[['total_gd_kw', 'RE', 'CO', 'IN', 'pct_RE', 'pct_CO', 'pct_IN']].fillna(0)

# --- AQUI EST√Å O TRUQUE DO VISUAL CLEAN ---
# Criamos colunas novas que j√° combinam o Valor + (%)
gdf_mapa['txt_residencial'] = gdf_mapa['RE'].astype(int).astype(str) + " (" + gdf_mapa['pct_RE'].astype(str) + "%)"
gdf_mapa['txt_comercial']   = gdf_mapa['CO'].astype(int).astype(str) + " (" + gdf_mapa['pct_CO'].astype(str) + "%)"
gdf_mapa['txt_industrial']  = gdf_mapa['IN'].astype(int).astype(str) + " (" + gdf_mapa['pct_IN'].astype(str) + "%)"

# Recalcular densidade GD
gdf_proj = gdf_mapa.to_crs(epsg=31983)
gdf_mapa['area_km2'] = gdf_proj.geometry.area / 1e6
gdf_mapa['densidade_gd'] = (gdf_mapa['total_gd_kw'] / gdf_mapa['area_km2']).round(1)

# ---------------------------------------------------------
# 4. MAPA FINAL COM TOOLTIP CLEAN
# ---------------------------------------------------------
print("üó∫Ô∏è Gerando Mapa Otimizado...")

m = folium.Map(location=[-23.5, -47.4], zoom_start=11)

cores_perfil = {
    'Residencial': '#3388ff', # Azul
    'Comercial': '#ff3333',   # Vermelho
    'Industrial': '#800080',  # Roxo
    'Misto': '#FFA500'        # Laranja
}

for categoria in ['Residencial', 'Comercial', 'Industrial', 'Misto']:
    subset = gdf_mapa[gdf_mapa['classificacao'] == categoria]

    if len(subset) == 0: continue

    fg = folium.FeatureGroup(name=f"{categoria} (Camada)")

    folium.GeoJson(
        subset,
        style_function=lambda x, cor=cores_perfil[categoria]: {
            'fillColor': cor,
            'color': 'black',
            'weight': 1,
            'fillOpacity': 0.6
        },
        tooltip=folium.GeoJsonTooltip(
            fields=[
                'NOME',
                'classificacao',
                'txt_residencial', # Usamos as colunas formatadas aqui
                'txt_comercial',
                'txt_industrial',
                'total_gd_kw'
            ],
            aliases=[
                'Subesta√ß√£o:',
                'PERFIL:',
                'Resid√™ncias:', # O alias fica curto
                'Com√©rcios:',
                'Ind√∫strias:',
                'Pot√™ncia Solar (kW):'
            ],
            localize=True
        )
    ).add_to(fg)
    fg.add_to(m)

folium.LayerControl().add_to(m)
m.save('mapa_clean.html')
m



import folium
import pandas as pd

# ---------------------------------------------------------
# 1. PREPARA√á√ÉO DOS DADOS COMPLETOS
# ---------------------------------------------------------
print("üìä Calculando estat√≠sticas detalhadas...")

# Garantir tipos macro
df_uc['tipo_macro'] = df_uc['CLAS_SUB'].str[:2]

# Tabela Din√¢mica: Contagem absoluta de cada tipo
# Isso cria colunas: CO, IN, RE, RU, PP, etc. com a contagem real
stats = df_uc.groupby(['SUB', 'tipo_macro']).size().unstack(fill_value=0)

# Calcular Totais e Porcentagens
stats['TOTAL'] = stats.sum(axis=1)
stats['pct_IN'] = (stats['IN'] / stats['TOTAL'] * 100).round(1) if 'IN' in stats else 0
stats['pct_CO'] = (stats['CO'] / stats['TOTAL'] * 100).round(1) if 'CO' in stats else 0
stats['pct_RE'] = (stats['RE'] / stats['TOTAL'] * 100).round(1) if 'RE' in stats else 0

# Garantir que as colunas existam mesmo se forem zero (para n√£o quebrar o c√≥digo)
for col in ['RE', 'CO', 'IN']:
    if col not in stats.columns: stats[col] = 0

# ---------------------------------------------------------
# 2. L√ìGICA DE CLASSIFICA√á√ÉO (4 TIPOS)
# ---------------------------------------------------------
def definir_perfil_4_tipos(row):
    # 1. Prioridade Industrial: Se tiver carga fabril relevante (> 1%)
    if row['pct_IN'] >= 1.0:
        return 'Industrial'

    # 2. Prioridade Comercial: Se tiver com√©rcio relevante (> 10%)
    elif row['pct_CO'] >= 10.0:
        return 'Comercial'

    # 3. Puramente Residencial: Se for quase s√≥ casa (> 90%)
    elif row['pct_RE'] >= 90.0:
        return 'Residencial'

    # 4. Misto: O "Meio Termo" (Ex: 85% casa, 14% com√©rcio)
    else:
        return 'Misto'

stats['classificacao'] = stats.apply(definir_perfil_4_tipos, axis=1)

# ---------------------------------------------------------
# 3. UNIFICA√á√ÉO (MERGE)
# ---------------------------------------------------------
# Juntar com a geometria das subesta√ß√µes
gdf_mapa = gdf_sub.merge(stats, left_on='COD_ID', right_index=True, how='left')

# Juntar com dados de Gera√ß√£o Distribu√≠da (do passo anterior)
gdf_mapa = gdf_mapa.merge(gd_sum, left_on='COD_ID', right_on='SUB', how='left')
gdf_mapa['total_gd_kw'] = gdf_mapa['total_gd_kw'].fillna(0)

# Recalcular densidade GD
gdf_proj = gdf_mapa.to_crs(epsg=31983)
gdf_mapa['area_km2'] = gdf_proj.geometry.area / 1e6
gdf_mapa['densidade_gd'] = (gdf_mapa['total_gd_kw'] / gdf_mapa['area_km2']).round(1)

# ---------------------------------------------------------
# 4. MAPA FINAL COM TOOLTIP COMPLETO
# ---------------------------------------------------------
print("üó∫Ô∏è Gerando Mapa com 4 Categorias...")

m = folium.Map(location=[-23.5, -47.4], zoom_start=11)

# Cores para as 4 categorias
cores_perfil = {
    'Residencial': '#3388ff', # Azul
    'Comercial': '#ff3333',   # Vermelho
    'Industrial': '#800080',  # Roxo
    'Misto': '#FFA500'        # Laranja (Orange)
}

# Criar Camadas por Categoria
for categoria in ['Residencial', 'Comercial', 'Industrial', 'Misto']:
    subset = gdf_mapa[gdf_mapa['classificacao'] == categoria]

    if len(subset) == 0: continue

    fg = folium.FeatureGroup(name=f"{categoria} (Camada)")

    folium.GeoJson(
        subset,
        style_function=lambda x, cor=cores_perfil[categoria]: {
            'fillColor': cor,
            'color': 'black',
            'weight': 1,
            'fillOpacity': 0.6
        },
        # AQUI EST√Å A M√ÅGICA: O Tooltip mostra TODOS os dados
        tooltip=folium.GeoJsonTooltip(
            fields=[
                'NOME',
                'classificacao',
                'RE', 'pct_RE',
                'CO', 'pct_CO',
                'IN', 'pct_IN',
                'total_gd_kw'
            ],
            aliases=[
                'Subesta√ß√£o:',
                'PERFIL:',
                'Qtd Casas:', '% Casas:',
                'Qtd Com√©rcios:', '% Com√©rcio:',
                'Qtd Ind√∫strias:', '% Ind√∫stria:',
                'Pot√™ncia Solar (kW):'
            ],
            localize=True
        )
    ).add_to(fg)
    fg.add_to(m)

folium.LayerControl().add_to(m)
m.save('mapa_4_perfis_detalhado.html')
m

# 6. GERAR MAPA INTERATIVO COM FILTROS
# ---------------------------------------------------------
print("5. Gerando Mapa com Filtros por Categoria...")

m = folium.Map(location=[-23.5, -47.4], zoom_start=11)

# Definir as cores
cores = {
    'Residencial': '#3388ff', # Azul
    'Comercial': '#ff3333',   # Vermelho
    'Industrial': '#800080',  # Roxo
    'Rural': '#228B22',       # Verde
    'Misto': '#808080'        # Cinza
}

# Criar uma lista de todas as categorias que existem nos seus dados
categorias = gdf_final['predominante_label'].unique()

# LOOP M√ÅGICO: Cria uma camada separada para cada categoria
for categoria in categorias:

    # 1. Filtrar o Dataframe (S√≥ pega as subesta√ß√µes dessa categoria)
    subset = gdf_final[gdf_final['predominante_label'] == categoria]

    # Se n√£o tiver dados, pula
    if len(subset) == 0: continue

    # 2. Criar o Grupo (A "Pasta" no menu do mapa)
    fg = folium.FeatureGroup(name=categoria)

    # 3. Adicionar os pol√≠gonos nesse grupo
    folium.GeoJson(
        subset,
        style_function=lambda x, cor=cores.get(categoria, 'gray'): {
            'fillColor': cor,
            'color': 'black',
            'weight': 1,
            'fillOpacity': 0.6
        },
        tooltip=folium.GeoJsonTooltip(
            fields=['NOME', 'predominante_label', 'penetracao_label', 'total_gd_kw', 'densidade_gd'],
            aliases=['Subesta√ß√£o:', 'Perfil:', 'Penetra√ß√£o Solar:', 'Total Solar (kW):', 'Densidade (kW/km¬≤):'],
            localize=True
        )
    ).add_to(fg)

    # 4. Adicionar o grupo ao mapa
    fg.add_to(m)

# Adicionar o controle de camadas (O bot√£ozinho no canto superior direito)
folium.LayerControl(collapsed=False).add_to(m)

# Salvar
m.save('mapa_desafio_com_filtros.html')
m

# --- AUDITORIA DE DADOS ---
print("üìä PROVA REAL: Contagem de Consumidores por Subesta√ß√£o")

# 1. Vamos ver os totais gerais da base inteira
print("\n--- Total Geral de Consumidores na Base ---")
print(df_uc['tipo_macro'].value_counts())

# 2. Vamos pegar uma Subesta√ß√£o espec√≠fica para auditar
# (Pegamos a primeira que aparecer na lista)
exemplo_sub = gdf_final.iloc[0]['NOME']
cod_sub = gdf_final.iloc[0]['COD_ID'] # O c√≥digo de liga√ß√£o

print(f"\n--- Auditando a Subesta√ß√£o: {exemplo_sub} (C√≥d: {cod_sub}) ---")

# Filtrar os consumidores s√≥ dessa subesta√ß√£o
audit = df_uc[df_uc['SUB'] == cod_sub]['tipo_macro'].value_counts()
print(audit)

print("\n------------------------------------------------")
print("CONCLUS√ÉO:")
if 'RE' in audit and 'CO' in audit:
    razao = audit['RE'] / audit['CO']
    print(f"Para cada 1 Com√©rcio, existem {razao:.1f} Resid√™ncias nessa √°rea.")
    print("Por isso o mapa fica Azul (Residencial ganha na contagem).")
else:
    print("Dados insuficientes para calcular a raz√£o.")

import geopandas as gpd
import pandas as pd
import folium

# --- CONFIGURA√á√ÉO ---
caminho_gdb = "/content/dados_aneel/CPFL_Piratininga_2937_2024-12-31_V11_20250729-0804.gdb"

print("üöÄ Iniciando processamento de Intelig√™ncia de Dados...")

# 1. CARREGAR AS CAMADAS
# ---------------------------------------------------------
print("1. Carregando dados geogr√°ficos e tabelas...")
gdf_sub = gpd.read_file(caminho_gdb, layer='SUB') # Mapa das Subesta√ß√µes

# Carregar tabelas (sem geometria para ser mais r√°pido)
# ignore_geometry=True √© importante aqui pois s√£o tabelas pesadas
df_uc = gpd.read_file(caminho_gdb, layer='UCBT_tab', ignore_geometry=True)
df_gd = gpd.read_file(caminho_gdb, layer='UGBT_tab', ignore_geometry=True)

print(f"   -> Subesta√ß√µes carregadas: {len(gdf_sub)}")
print(f"   -> Consumidores carregados: {len(df_uc)}")
print(f"   -> Geradores Solares carregados: {len(df_gd)}")

# 2. RESPONDER PERGUNTA 1: PERFIL PREDOMINANTE
# ---------------------------------------------------------
print("2. Calculando Perfil de Consumo...")

# Simplificar a classe (Pegar s√≥ as 2 primeiras letras: RE, CO, IN, RU, PO)
# RE=Residencial, CO=Comercial, IN=Industrial, PO=Poder P√∫blico, RU=Rural
df_uc['tipo_macro'] = df_uc['CLAS_SUB'].str[:2]

# Contar quantos de cada tipo existem por Subesta√ß√£o
perfil = df_uc.groupby(['SUB', 'tipo_macro']).size().unstack(fill_value=0)

# Definir o vencedor (quem tem mais conex√µes)
perfil['predominante'] = perfil.idxmax(axis=1)

# Traduzir para portugu√™s bonito
mapa_nomes = {'RE': 'Residencial', 'CO': 'Comercial', 'IN': 'Industrial', 'RU': 'Rural', 'PO': 'Poder P√∫blico'}
perfil['predominante_label'] = perfil['predominante'].map(mapa_nomes).fillna('Misto')

# 3. RESPONDER PERGUNTA 2: GERA√á√ÉO DISTRIBU√çDA (MMGD)
# ---------------------------------------------------------
print("3. Calculando Penetra√ß√£o de Gera√ß√£o Distribu√≠da...")

# Somar a Pot√™ncia Instalada (POT_INST) por Subesta√ß√£o
# Assumindo que POT_INST est√° em kW (padr√£o ANEEL)
gd_sum = df_gd.groupby('SUB')['POT_INST'].sum().reset_index()
gd_sum.rename(columns={'POT_INST': 'total_gd_kw'}, inplace=True)

# 4. UNIFICAR TUDO NO MAPA (MERGE)
# ---------------------------------------------------------
print("4. Unificando dados...")

# Juntar Perfil (Usando COD_ID da subesta√ß√£o = SUB da tabela)
gdf_final = gdf_sub.merge(perfil, left_on='COD_ID', right_index=True, how='left')

# Juntar Gera√ß√£o
gdf_final = gdf_final.merge(gd_sum, left_on='COD_ID', right_on='SUB', how='left')

# Preencher com zero onde n√£o tem GD
gdf_final['total_gd_kw'] = gdf_final['total_gd_kw'].fillna(0)

# 5. C√ÅLCULO DE DENSIDADE (INTELIG√äNCIA GEOGR√ÅFICA)
# ---------------------------------------------------------
# A √°rea original est√° em graus. Vamos converter para KM¬≤ projetando para SIRGAS 2000 UTM 23S
# (Isso √© crucial para a m√©trica ficar correta)
gdf_proj = gdf_final.to_crs(epsg=31983)
gdf_final['area_km2'] = gdf_proj.geometry.area / 1e6

# Densidade: kW por km¬≤
gdf_final['densidade_gd'] = gdf_final['total_gd_kw'] / gdf_final['area_km2']

# Regra de classifica√ß√£o
def classificar_penetracao(d):
    if d < 10: return "Baixa"
    elif d < 100: return "M√©dia"
    else: return "Alta"

gdf_final['penetracao_label'] = gdf_final['densidade_gd'].apply(classificar_penetracao)

# 6. GERAR MAPA INTERATIVO
# ---------------------------------------------------------
print("5. Gerando Mapa...")

# Criar mapa
m = folium.Map(location=[-23.5, -47.4], zoom_start=10) # Centro aprox. da regi√£o CPFL Piratininga

# Fun√ß√£o de estilo (Cor baseada no perfil)
def style_function(feature):
    perfil = feature['properties']['predominante_label']
    colors = {
        'Residencial': '#3388ff', # Azul
        'Comercial': '#ff3333',   # Vermelho
        'Industrial': '#purple',  # Roxo
        'Rural': '#green'         # Verde
    }
    return {
        'fillColor': colors.get(perfil, 'gray'),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.6
    }

# Adicionar Pol√≠gonos
folium.GeoJson(
    gdf_final,
    name='Intelig√™ncia de Subesta√ß√µes',
    style_function=style_function,
    tooltip=folium.GeoJsonTooltip(
        fields=['NOME', 'predominante_label', 'penetracao_label', 'total_gd_kw', 'densidade_gd'],
        aliases=['Subesta√ß√£o:', 'Perfil:', 'Penetra√ß√£o Solar:', 'Total Solar (kW):', 'Densidade (kW/km¬≤):'],
        localize=True
    )
).add_to(m)

folium.LayerControl().add_to(m)

# Salvar e mostrar
m.save('mapa_desafio.html')
m

import geopandas as gpd
import pandas as pd

caminho_gdb = "/content/dados_aneel/CPFL_Piratininga_2937_2024-12-31_V11_20250729-0804.gdb"

print("üîç Lendo amostras das camadas...")

# 1. Carregar Subesta√ß√µes (SUB)
# Aqui esperamos ver a geometria (Polygon/Point) e o Nome/C√≥digo da Subesta√ß√£o
gdf_sub = gpd.read_file(caminho_gdb, layer='SUB')
print("\n--- CAMADA: SUB (Subesta√ß√µes) ---")
print(gdf_sub.head(3))
print("Colunas:", gdf_sub.columns.tolist())

# 2. Carregar Consumidores (UCBT_tab)
# Queremos ver se tem coluna 'CLAS_SUB' (Classe) e algum c√≥digo que ligue √† SUB
try:
    # √Äs vezes _tab n√£o tem geometria, ent√£o usamos ignore_geometry=True se falhar,
    # mas vamos tentar ler normal primeiro.
    gdf_uc = gpd.read_file(caminho_gdb, layer='UCBT_tab', rows=100)
    print("\n--- CAMADA: UCBT_tab (Consumidores) ---")
    print(gdf_uc.head(3)[['PAC', 'CTMT', 'SUB', 'CONJ', 'CLAS_SUB'] if 'CLAS_SUB' in gdf_uc.columns else gdf_uc.columns])
    print("Colunas principais dispon√≠veis:", gdf_uc.columns.tolist())
except Exception as e:
    print(f"\nErro ao ler UCBT: {e}")

# 3. Carregar Gera√ß√£o (UGBT_tab)
# Queremos ver a Pot√™ncia Instalada
try:
    gdf_ug = gpd.read_file(caminho_gdb, layer='UGBT_tab', rows=100)
    print("\n--- CAMADA: UGBT_tab (Gera√ß√£o Solar) ---")
    print(gdf_ug.head(3))
    print("Colunas:", gdf_ug.columns.tolist())
except Exception as e:
    print(f"\nErro ao ler UGBT: {e}")

import fiona

# Caminho exato que apareceu no seu log de unzip
caminho_gdb = "/content/dados_aneel/CPFL_Piratininga_2937_2024-12-31_V11_20250729-0804.gdb"

print(f"Lendo conte√∫do de: {caminho_gdb} ...")

try:
    # Lista todas as camadas dispon√≠veis dentro do GDB
    layers = fiona.listlayers(caminho_gdb)

    print("-" * 30)
    print(f"ENCONTREI {len(layers)} CAMADAS:")
    print("-" * 30)

    # Imprime os nomes para a gente escolher
    for i, nome in enumerate(layers):
        # Destacar as camadas mais importantes para o desafio
        if "SUB" in nome or "SSD" in nome:
            print(f"üìç {i}: {nome} <--- PROV√ÅVEL SUBESTA√á√ÉO")
        elif "UC" in nome or "CONSUMIDOR" in nome:
            print(f"üë• {i}: {nome} <--- PROV√ÅVEIS CONSUMIDORES")
        else:
            print(f"{i}: {nome}")

except Exception as e:
    print(f"Erro ao ler o arquivo: {e}")

!unzip "/CPFL_Piratininga_2937_2024-12-31_V11_20250729-0804.gdb.zip" -d /content/dados_aneel

import os

print("üïµÔ∏è‚Äç‚ôÇÔ∏è Iniciando busca profunda em todo o sistema...")

# Pastas de sistema que vamos pular para n√£o travar
ignorar = {'/proc', '/sys', '/dev', '/run', '/boot', '/lib', '/usr', '/bin', '/sbin'}

encontrados = []

# Come√ßa da raiz absoluta (/)
for root, dirs, files in os.walk("/"):
    # Remove pastas de sistema da busca
    dirs[:] = [d for d in dirs if os.path.join(root, d) not in ignorar]

    for name in files:
        # Procura por ZIP ou GDB
        if name.lower().endswith(('.zip', '.gdb')):
            caminho_completo = os.path.join(root, name)
            try:
                tamanho_mb = os.path.getsize(caminho_completo) / (1024 * 1024)
                # S√≥ mostra se for maior que 1MB (para ignorar lixo do sistema)
                if tamanho_mb > 1:
                    encontrados.append((caminho_completo, tamanho_mb))
            except:
                pass # Ignora erros de permiss√£o

print("-" * 40)
if encontrados:
    print(f"‚úÖ SUCESSO! Encontrei {len(encontrados)} arquivo(s):")
    for caminho, tamanho in encontrados:
        print(f"\nüìÇ CAMINHO: {caminho}")
        print(f"   TAMANHO: {tamanho:.2f} MB")
        print("   Copie o caminho acima para usar no unzip!")
else:
    print("‚ùå NADA ENCONTRADO.")
    print("O arquivo realmente n√£o est√° no sistema. O upload n√£o funcionou.")
print("-" * 40)

!unzip /CPFL_Piratininga_2937_2024-12-31_V11_20250729-0804.gdb.zip

pip install pandas geopandas shapely folium matplotlib rtree